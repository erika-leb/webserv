
valgrind --trace-children=yes --track-fds=yes --leak-check=full --show-leak-kinds=all ./webserv

a faire encore pour config :
- directive retrun -> renvoyer le fichier (http://localhost:8081/Makefile doit renvoyer le Makefile de kiki)



- verifier si il y a des parametres non supportes -> erreur 501


RESTE A FAIRE ==
- lire le code cgi de thibault (erika)
- gerer la directive cgi (Thibault)
- ameliorer le parsing de thibault
- multipart ?


TEST =
- refaire ifError
- refaire test ip different  et port identique




- si le fichier de conf ne termine pas par .conf c'est grave ?

La logique standard est :
-match le plus long prÃ©fixe (ex : /images/hd/ avant /images/)
-si aucun match : fallback au location /

logique de request = - on verifie que le _pathfile (le fichier) existe (checkFile)
- on met a jour le _pathfile si ce n'est pas le cas (ifError)
- on reverifie que le pathfile existe (au cas ou le _pahtfile aurait ete change pour un chemin d'erreur) (checkFile encore)
- on remet

- root = pas de / ni avant ni apres OK   ex : html
- location = / a la fin oui mais apres normalement meme si on dirait que non   ex : /test
- fichier = slash au debut mais pas a la fin OK ex : /04.html
- cgi = slash avant mais pas apres


-test feuille
-test ecole
-rendre tout propre



tests :

siege -b -t 30s http://localhost:8080

curl -v -H "Transfer-Encoding: chunked" -H "Expect:" --data-binary "@test_50mo.txt" http://localhost:8080/test/testyyyyy




ğŸ§© Ã‰TAPE 1 â€” VÃ©rifie que ton serveur â€œÃ©couteâ€ correctement

Avant tout, assure-toi que ton serveur :

crÃ©e la socket dâ€™Ã©coute avec socket(),

la rend non bloquante (fcntl(fd, F_SETFL, O_NONBLOCK)),

la lie (bind()),

lâ€™Ã©coute (listen()),

lâ€™ajoute dans poll() comme â€œsocket dâ€™Ã©couteâ€.

âœ… Test :

curl localhost:8080

â†’ tu dois voir une tentative de connexion (mÃªme si tu ne renvoies encore rien).
Si tu vois ton message â€œconnexion acceptÃ©eâ€, câ€™est bon.

âš™ï¸ Ã‰TAPE 2 â€” GÃ©rer lâ€™acceptation des nouveaux clients

Quand poll() indique un Ã©vÃ©nement POLLIN sur la socket dâ€™Ã©coute :

tu fais accept(),

tu rends le nouveau socket client non bloquant,

tu lâ€™ajoutes dans la liste des pollfd surveillÃ©s.

ğŸ’¡ Attention : il faut toujours vÃ©rifier le retour de accept() et errno == EAGAIN si tu es en non-bloquant.

ğŸ“¥ Ã‰TAPE 3 â€” Lire la requÃªte HTTP

Quand poll() te signale POLLIN sur un client :

tu appelles recv() ou read() dans une boucle (jusquâ€™Ã  EAGAIN ou n == 0).

tu stockes les donnÃ©es reÃ§ues dans un buffer (souvent une std::string par client).

âš ï¸ Quand n == 0, cela veut dire que le client a fermÃ© la connexion â†’ tu supprimes la socket du poll().

ğŸ“œ Ã‰TAPE 4 â€” Parser la requÃªte HTTP

DÃ¨s que tu as reÃ§u une requÃªte complÃ¨te (tu dÃ©tectes "\r\n\r\n" Ã  la fin des headers), tu la analyses :

SÃ©pare la premiÃ¨re ligne â†’ mÃ©thode, chemin, version.
Exemple : "GET /index.html HTTP/1.1"

Lis les headers (jusquâ€™Ã  la ligne vide).

Si Content-Length existe â†’ lis le body de la requÃªte.

âš™ï¸ Tu peux Ã©crire une petite classe HTTPRequest qui stocke :
struct HTTPRequest {
	std::string method;
	std::string path;
	std::string version;
	std::map<std::string, std::string> headers;
	std::string body;
};

ğŸ“¤ Ã‰TAPE 5 â€” GÃ©nÃ©rer une rÃ©ponse HTTP

Une fois la requÃªte complÃ¨te et parsÃ©e, ton serveur doit rÃ©pondre.
Par exemple pour une requÃªte GET basique :
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 13

Hello, world!

Ton code doit donc construire une HTTPResponse :
struct HTTPResponse {
	std::string status_line;
	std::map<std::string, std::string> headers;
	std::string body;
};Et lâ€™envoyer avec send() dans le socket client.

ğŸ” Ã‰TAPE 6 â€” Ajouter la gestion POLLOUT

Une fois ta rÃ©ponse prÃªte, tu modifies ton pollfd :

tu dÃ©sactives POLLIN,

tu actives POLLOUT (tu veux maintenant Ã©crire sur la socket).

Quand poll() te signale POLLOUT, tu fais un send() non bloquant.
Quand toute la rÃ©ponse a Ã©tÃ© envoyÃ©e :

si la connexion doit rester ouverte (Connection: keep-alive) â†’ tu repasses en POLLIN;

sinon tu fermes la socket.

ğŸ”§ Ã‰TAPE 7 â€” GÃ©rer plusieurs clients et le nettoyage

Tu dois gÃ©rer proprement :

suppression des sockets mortes (n == 0 ou POLLERR),

libÃ©ration de la mÃ©moire,

et Ã©ventuellement un timeout (si un client reste ouvert sans rien envoyer).

ğŸš€ Ã‰TAPE 8 â€” Lire le fichier de configuration (comme nginx.conf)

Tu dois maintenant commencer Ã  :

parser un fichier config.conf que ton exÃ©cutable prend en paramÃ¨tre ;

crÃ©er plusieurs serveurs (listen 8080, listen 8081, etc.) ;

gÃ©rer les â€œlocationsâ€ (location /upload, location /images...).

Mais cette Ã©tape vient aprÃ¨s que ton serveur minimal fonctionne.













requete google http://localhost:8081/kiki/AMfrvfr
GET /kiki/AMfrvfr HTTP/1.1
Host: localhost:8081

resultat = gerhain 404


requte echo -ne "GET /kiki/AMfrvfr HTP/1.1\r\nHost: 127.0.0.1:8081\r\n\r\n" | nc 127.0.0.1 8081
(curl)
GET /kiki/AMfrvfr HTP/1.1
Host: 127.0.0.1:8081

resultat = so funny 400
