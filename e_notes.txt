
valgrind --trace-children=yes --track-fds=yes --leak-check=full --show-leak-kinds=all ./webserv
a faire encore pour config :
- voir quelles directives on accepte (accepte-on les meme a chaque niveau ?) voir sujet
- decider quelles ou si des directives peuvent se trouver en doubon
- implementer les elements de la config dans le serveur
- mettre l'ip
- mettre des securites par rapport a l'endroit un client peut recuperer/modif/suppr des fichiers

a faire pour serveur:
- verifier la date de derniere connection du client pour le tej apres un certain temps (gerer le timeout)

a faire pour requete:
- post
- mettre securite pour ne pas accepter .. dans le chemin du fichier


Rappel fichier config :
un serveur nginx = suite de directives
3 niveaux
- niveau global : contient des directives et herite des deux autres niveaux (map)
- niveau serveur : herite des directives globales et possede lui-meme des directives et des locations
- niveau location : herite du global et du serveru et possede egalement des directives (si la directive etait deja definie a un niveau plus haut, la valeur au niveau de la location a priorite et on ecrase la valeur)
1 directive = 1 URL/IRL -> 1 def, 1 valeur
Creer 3 classes = global config, server congif et location config

- si deeux serveurs avec memes adresse que fait-on ? ie comment gerer le virtual hosting ?

regles
- aucune directive obligatoire au niveau global (root, index, qutoindex on/off, cgi8handler, client_max_body_size, error_page )
- niveau serveur : listen et root obligatoire, index optionell (fichier par dÃ©fault; index.html), error_pageet location optionnel
- location optionnel; directives optionnel
location /images {
}
c'est ok


La logique standard est :
-match le plus long prÃ©fixe (ex : /images/hd/ avant /images/)
-si aucun match : fallback au location /


















ğŸ§© Ã‰TAPE 1 â€” VÃ©rifie que ton serveur â€œÃ©couteâ€ correctement

Avant tout, assure-toi que ton serveur :

crÃ©e la socket dâ€™Ã©coute avec socket(),

la rend non bloquante (fcntl(fd, F_SETFL, O_NONBLOCK)),

la lie (bind()),

lâ€™Ã©coute (listen()),

lâ€™ajoute dans poll() comme â€œsocket dâ€™Ã©couteâ€.

âœ… Test :

curl localhost:8080

â†’ tu dois voir une tentative de connexion (mÃªme si tu ne renvoies encore rien).
Si tu vois ton message â€œconnexion acceptÃ©eâ€, câ€™est bon.

âš™ï¸ Ã‰TAPE 2 â€” GÃ©rer lâ€™acceptation des nouveaux clients

Quand poll() indique un Ã©vÃ©nement POLLIN sur la socket dâ€™Ã©coute :

tu fais accept(),

tu rends le nouveau socket client non bloquant,

tu lâ€™ajoutes dans la liste des pollfd surveillÃ©s.

ğŸ’¡ Attention : il faut toujours vÃ©rifier le retour de accept() et errno == EAGAIN si tu es en non-bloquant.

ğŸ“¥ Ã‰TAPE 3 â€” Lire la requÃªte HTTP

Quand poll() te signale POLLIN sur un client :

tu appelles recv() ou read() dans une boucle (jusquâ€™Ã  EAGAIN ou n == 0).

tu stockes les donnÃ©es reÃ§ues dans un buffer (souvent une std::string par client).

âš ï¸ Quand n == 0, cela veut dire que le client a fermÃ© la connexion â†’ tu supprimes la socket du poll().

ğŸ“œ Ã‰TAPE 4 â€” Parser la requÃªte HTTP

DÃ¨s que tu as reÃ§u une requÃªte complÃ¨te (tu dÃ©tectes "\r\n\r\n" Ã  la fin des headers), tu la analyses :

SÃ©pare la premiÃ¨re ligne â†’ mÃ©thode, chemin, version.
Exemple : "GET /index.html HTTP/1.1"

Lis les headers (jusquâ€™Ã  la ligne vide).

Si Content-Length existe â†’ lis le body de la requÃªte.

âš™ï¸ Tu peux Ã©crire une petite classe HTTPRequest qui stocke :
struct HTTPRequest {
	std::string method;
	std::string path;
	std::string version;
	std::map<std::string, std::string> headers;
	std::string body;
};

ğŸ“¤ Ã‰TAPE 5 â€” GÃ©nÃ©rer une rÃ©ponse HTTP

Une fois la requÃªte complÃ¨te et parsÃ©e, ton serveur doit rÃ©pondre.
Par exemple pour une requÃªte GET basique :
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 13

Hello, world!

Ton code doit donc construire une HTTPResponse :
struct HTTPResponse {
	std::string status_line;
	std::map<std::string, std::string> headers;
	std::string body;
};Et lâ€™envoyer avec send() dans le socket client.

ğŸ” Ã‰TAPE 6 â€” Ajouter la gestion POLLOUT

Une fois ta rÃ©ponse prÃªte, tu modifies ton pollfd :

tu dÃ©sactives POLLIN,

tu actives POLLOUT (tu veux maintenant Ã©crire sur la socket).

Quand poll() te signale POLLOUT, tu fais un send() non bloquant.
Quand toute la rÃ©ponse a Ã©tÃ© envoyÃ©e :

si la connexion doit rester ouverte (Connection: keep-alive) â†’ tu repasses en POLLIN;

sinon tu fermes la socket.

ğŸ”§ Ã‰TAPE 7 â€” GÃ©rer plusieurs clients et le nettoyage

Tu dois gÃ©rer proprement :

suppression des sockets mortes (n == 0 ou POLLERR),

libÃ©ration de la mÃ©moire,

et Ã©ventuellement un timeout (si un client reste ouvert sans rien envoyer).

ğŸš€ Ã‰TAPE 8 â€” Lire le fichier de configuration (comme nginx.conf)

Tu dois maintenant commencer Ã  :

parser un fichier config.conf que ton exÃ©cutable prend en paramÃ¨tre ;

crÃ©er plusieurs serveurs (listen 8080, listen 8081, etc.) ;

gÃ©rer les â€œlocationsâ€ (location /upload, location /images...).

Mais cette Ã©tape vient aprÃ¨s que ton serveur minimal fonctionne.
